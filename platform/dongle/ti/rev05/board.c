//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

#ifndef __BOARD_C__
#define __BOARD_C__
/******************************************************************************
* includes ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
#include "file.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_nvic.h"
#include "inc/hw_gpio.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_uart.h"
#include "driverlib/adc.h"
#include "driverlib/debug.h"
#include "driverlib/eeprom.h"
#include "driverlib/gpio.h"
#include "driverlib/i2c.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/ssi.h"
#include "driverlib/sysctl.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"
#include "driverlib/usb.h"
#include "driverlib/udma.h"
//USB Lib inc
#ifdef USE_USBLIB
  #include "usblib/usblib.h"
  #include "usblib/usb-ids.h"
  #include "usblib/device/usbdevice.h"
  #include "usblib/device/usbdbulk.h"
#endif //#ifdef USE_USBLIB
//end USB Lib inc

#include "utils_inc/error_codes.h"
#include "utils_inc/proj_debug.h"
#include "utils_inc/osal.h"

#include "inc/tm4c1233h6pm.h"
#include "board.h"


/******************************************************************************
* defines /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
//radio uart DMA defines
#define USE_RADIO_UART_DMA      false
#define DMA_RDIO_RCV_BUFFSZ     1024
#define NUM_DMA_RDIO_RCV_BUFFS  3

#define DMA_RDIO_TX_BUFFSZ             256
#define NUM_DMA_RDIO_TX_BUFFS          3
#define RADIO_TX_UDMA_CHANNEL_BITMASK  0b00000000100000000000000000000000
#define RADIO_RX_UDMA_CHANNEL_BITMASK  0b00000000010000000000000000000000

//USB defines
#define USB_THREE_SEC_DATA_CONN_DELAY   3000

//HW delay defines
//#define HW_DELAY_MSDIV 1000
#define HW_DELAY_MSDIV 3000

//ADC defines
#define ADC_SPI_BYTES_TO_READ(n)   n - 1
#define ADC_SPI_BYTES_TO_WRITE(n)  n - 1
#define ADC_SPI_BITRATE_1M         1000000
#define ADC_SPI_BITRATE_2M         2000000
#define ADC_SPI_BITRATE_4M         4000000

/******************************************************************************
* variables ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
//UART variables
bool     bIs_usart_params_configed = false;
volatile bool bIs_usart_data = false;
volatile bool bIs_uart_done = false;
volatile uint32_t uiCTS_int_status = 0;
volatile bool bIs_usart_timeout = false;
volatile bool bRdio_track_timeout_tick = false;
volatile uint32_t uiRdio_timeout_tick = 0;
volatile int  iNum_cmnd_buffs = 0;
volatile int  iNum_cts_procs = 0;
volatile bool bIs_DMA_transmit_in_process = false;

///////////////////////////////////////////////////////////////////////////////
//USB variables
bool bIs_USB_Enabled = false;
volatile bool bIs_USB_sof = false;
#ifdef USE_USBLIB
//*****************************************************************************
//
// The size of the transmit and receive buffers used. 256 is chosen pretty
// much at random though the buffer should be at least twice the size of
// a maximum-sized USB packet.
//
//*****************************************************************************
#define BULK_BUFFER_SIZE 256

extern uint32_t RxHandler(void *pvCBData, uint32_t ui32Event,
                          uint32_t ui32MsgValue, void *pvMsgData);
extern uint32_t TxHandler(void *pvi32CBData, uint32_t ui32Event,
                          uint32_t ui32MsgValue, void *pvMsgData);

extern const tUSBBuffer g_sTxBuffer;
extern const tUSBBuffer g_sRxBuffer;
extern tUSBDBulkDevice g_sBulkDevice;
extern uint8_t g_pui8USBTxBuffer[];
extern uint8_t g_pui8USBRxBuffer[];

//*****************************************************************************
//
// The languages supported by this device.
//
//*****************************************************************************
const uint8_t g_pui8LangDescriptor[] =
{
    4,
    USB_DTYPE_STRING,
    USBShort(USB_LANG_EN_US)
};

//*****************************************************************************
//
// The manufacturer string.
//
//*****************************************************************************
const uint8_t g_pui8ManufacturerString[] =
{
    (17 + 1) * 2,
    USB_DTYPE_STRING,
    'T', 0, 'e', 0, 'x', 0, 'a', 0, 's', 0, ' ', 0, 'I', 0, 'n', 0, 's', 0,
    't', 0, 'r', 0, 'u', 0, 'm', 0, 'e', 0, 'n', 0, 't', 0, 's', 0,
};

//*****************************************************************************
//
// The product string.
//
//*****************************************************************************
const uint8_t g_pui8ProductString[] =
{
    (19 + 1) * 2,
    USB_DTYPE_STRING,
    'G', 0, 'e', 0, 'n', 0, 'e', 0, 'r', 0, 'i', 0, 'c', 0, ' ', 0, 'B', 0,
    'u', 0, 'l', 0, 'k', 0, ' ', 0, 'D', 0, 'e', 0, 'v', 0, 'i', 0, 'c', 0,
    'e', 0
};

//*****************************************************************************
//
// The serial number string.
//
//*****************************************************************************
const uint8_t g_pui8SerialNumberString[] =
{
    (8 + 1) * 2,
    USB_DTYPE_STRING,
    '1', 0, '2', 0, '3', 0, '4', 0, '5', 0, '6', 0, '7', 0, '8', 0
};

//*****************************************************************************
//
// The data interface description string.
//
//*****************************************************************************
const uint8_t g_pui8DataInterfaceString[] =
{
    (19 + 1) * 2,
    USB_DTYPE_STRING,
    'B', 0, 'u', 0, 'l', 0, 'k', 0, ' ', 0, 'D', 0, 'a', 0, 't', 0,
    'a', 0, ' ', 0, 'I', 0, 'n', 0, 't', 0, 'e', 0, 'r', 0, 'f', 0,
    'a', 0, 'c', 0, 'e', 0
};

//*****************************************************************************
//
// The configuration description string.
//
//*****************************************************************************
const uint8_t g_pui8ConfigString[] =
{
    (23 + 1) * 2,
    USB_DTYPE_STRING,
    'B', 0, 'u', 0, 'l', 0, 'k', 0, ' ', 0, 'D', 0, 'a', 0, 't', 0,
    'a', 0, ' ', 0, 'C', 0, 'o', 0, 'n', 0, 'f', 0, 'i', 0, 'g', 0,
    'u', 0, 'r', 0, 'a', 0, 't', 0, 'i', 0, 'o', 0, 'n', 0
};

//*****************************************************************************
//
// The descriptor string table.
//
//*****************************************************************************
const uint8_t * const g_ppui8StringDescriptors[] =
{
    g_pui8LangDescriptor,
    g_pui8ManufacturerString,
    g_pui8ProductString,
    g_pui8SerialNumberString,
    g_pui8DataInterfaceString,
    g_pui8ConfigString
};

#define NUM_STRING_DESCRIPTORS (sizeof(g_ppui8StringDescriptors) /                \
                                sizeof(uint8_t *))

//*****************************************************************************
//
// The bulk device initialization and customization structures. In this case,
// we are using USBBuffers between the bulk device class driver and the
// application code. The function pointers and callback data values are set
// to insert a buffer in each of the data channels, transmit and receive.
//
// With the buffer in place, the bulk channel callback is set to the relevant
// channel function and the callback data is set to point to the channel
// instance data. The buffer, in turn, has its callback set to the application
// function and the callback data set to our bulk instance structure.
//
//*****************************************************************************

tUSBDBulkDevice g_sBulkDevice =
{
    USB_VID_TI_1CBE,
    USB_PID_BULK,
    500,
    USB_CONF_ATTR_SELF_PWR,
    USBBufferEventCallback,
    (void *)&g_sRxBuffer,
    USBBufferEventCallback,
    (void *)&g_sTxBuffer,
    g_ppui8StringDescriptors,
    NUM_STRING_DESCRIPTORS
};

//*****************************************************************************
//
// Receive buffer (from the USB perspective).
//
//*****************************************************************************
uint8_t g_pui8USBRxBuffer[BULK_BUFFER_SIZE];
uint8_t g_pui8RxBufferWorkspace[USB_BUFFER_WORKSPACE_SIZE];
const tUSBBuffer g_sRxBuffer =
{
    false,                           // This is a receive buffer.
    RxHandler,                       // pfnCallback
    (void *)&g_sBulkDevice,          // Callback data is our device pointer.
    USBDBulkPacketRead,              // pfnTransfer
    USBDBulkRxPacketAvailable,       // pfnAvailable
    (void *)&g_sBulkDevice,          // pvHandle
    g_pui8USBRxBuffer,               // pi8Buffer
    BULK_BUFFER_SIZE,                // ui32BufferSize
    g_pui8RxBufferWorkspace          // pvWorkspace
};

//*****************************************************************************
//
// Transmit buffer (from the USB perspective).
//
//*****************************************************************************
uint8_t g_pui8USBTxBuffer[BULK_BUFFER_SIZE];
uint8_t g_pui8TxBufferWorkspace[USB_BUFFER_WORKSPACE_SIZE];
const tUSBBuffer g_sTxBuffer =
{
    true,                            // This is a transmit buffer.
    TxHandler,                       // pfnCallback
    (void *)&g_sBulkDevice,          // Callback data is our device pointer.
    USBDBulkPacketWrite,             // pfnTransfer
    USBDBulkTxPacketAvailable,       // pfnAvailable
    (void *)&g_sBulkDevice,          // pvHandle
    g_pui8USBTxBuffer,               // pi8Buffer
    BULK_BUFFER_SIZE,                // ui32BufferSize
    g_pui8TxBufferWorkspace          // pvWorkspace
};
#endif //#ifdef USE_USBLIB
//end USB variables
///////////////////////////////////////////////////////////////////////////////

//Waverform timer variables
volatile bool bWaveform_timer_tick = false;

//adc variables

//HW delay variables
uint32_t uiHW_delay_Sys_speed_1ms_ticks = 0;

//system speed variables
uint32_t uiCurrent_sys_speed = 0;
uint32_t uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_INDEX_COUNT] =
{
  0,         //INEEDMD_CPU_SPEED_NOT_SET
  80000000,  //INEEDMD_CPU_SPEED_FULL_EXTERNAL,
  40000000,  //INEEDMD_CPU_SPEED_HALF_EXTERNAL,
  20000000,  //INEEDMD_CPU_SPEED_QUARTER_EXTERNAL,
  80000000,  //INEEDMD_CPU_SPEED_FULL_INTERNAL,
  40000000,  //INEEDMD_CPU_SPEED_HALF_INTERNAL,
  40000000,  //INEEDMD_CPU_SPEED_HALF_INTERNAL_OSC,
  500000,    //INEEDMD_CPU_SPEED_SLOW_INTERNAL,
  30000      //INEEDMD_CPU_SPEED_REALLY_SLOW,
};

//Total time running variables
volatile uintmax_t uiRunClock_Sys_ms_count = 0;
volatile uint16_t  uiRunClock_Sys_ms       = 0;
volatile uint16_t  uiRunClock_Sys_sec      = 0;
volatile uint16_t  uiRunClock_Sys_min      = 0;
volatile uint16_t  uiRunClock_Sys_hour     = 0;
volatile uint16_t  uiRunClock_Sys_days     = 0;
volatile uint16_t  uiRunClock_Sys_years    = 0;

//Batt measure variables
bool bIs_Batt_measACD_enabled = false;

//LED and LED I2C variables
bool bIs_LEDI2D_Enabled = false;

//System sleep variables
bool bSystem_sleep_timer_expired = false;

// BIOS variables
bool bIs_BIOS_running = false;

//*****************************************************************************
// The control table used by the uDMA controller. This table must be aligned to a 1024 byte boundary.
//*****************************************************************************

/******************************************************************************
* external variables //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/

/******************************************************************************
* enums ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
typedef enum
{
  RB_NONE,
  RB_IWRAP_CMND,
  RB_INEEDMD_CMND,
  RB_OTHER
}eRcv_Buff_type;

eSYSTEM_SPEED_INDEX eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_NOT_SET;
/******************************************************************************
* structures //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
//DMA RX struct
typedef struct
{
  bool bBuff_free;
  eRcv_Buff_type eApp_Buff_Dest;
  uint8_t uiRcv_Buff[DMA_RDIO_RCV_BUFFSZ];
  uint16_t uiRcv_data_len;
}tDMA_RX_struct;  //dma transmit data struct

//DMA TX struct
typedef struct
{
  bool bBuff_free;
  uint8_t uiTx_Buff[DMA_RDIO_TX_BUFFSZ];
  uint16_t uiTx_data_len;
  bool bTx_done;
}tDMA_TX_struct;  //dma transmit data struct

#if USE_RADIO_UART_DMA == true
tDMA_RX_struct tDMA_RX_struct_array[NUM_DMA_RDIO_RCV_BUFFS];
tDMA_TX_struct tDMA_TX_struct_array[NUM_DMA_RDIO_TX_BUFFS];
#endif

//UART parameters
UART_Handle sRadio_UART_handle = NULL;
UART_Params sRadio_UART_params;

//CPU frequency parameters
Types_FreqHz sCPU_freq;

//SPI parameters
SPI_Handle tSPI_ADC_handle;
SPI_Params tSPI_ADC_params;

/******************************************************************************
* external functions //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
******************************************************************************/
extern void vIneedMD_radio_read_cb(UART_Handle sHandle, void *buf, size_t  count);
extern void vIneedMD_radio_write_cb(UART_Handle sHandle, void *buf, size_t  count);

/******************************************************************************
* name: vBSP_Power_System_Down
* description: sets the PSU enable pin low so the power monitor will shut down.
* !!!!WARNING!!!! This function will NOT return;
* param description: none
* return value description: none
******************************************************************************/
void vBSP_Power_System_Down(void)
{
  GPIO_write(EK_TM4C123GXL_LED_ENABLE, INEEDMD_LED_ENABLE_PIN_CLEAR);
  GPIO_write(EK_TM4C123GXL_PSU_ENABLE, INEEDMD_PSU_ENABLE_PIN_CLEAR);

  ROM_IntMasterDisable();
  ROM_SysTickIntDisable();
  ROM_SysTickDisable();
  while(1){};
}

/******************************************************************************
* name: vBSP_System_reset
* description: Resets the micro processor.
* !!!!WARNING!!!! This function will NOT return;
* param description: none
* return value description: none
******************************************************************************/
void vBSP_System_reset(void)
{
  ROM_IntMasterDisable();
  ROM_SysCtlReset();
  while(1){};
}

//*****************************************************************************
// name:
// description: sets the system speed according to the passed in parameter
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE set_system_speed (eSYSTEM_SPEED_INDEX eHow_Fast)
{
//#define DEBUG_set_system_speed
#ifdef DEBUG_set_system_speed
  #define  vDEBUG_SET_SYS_SPEED  vDEBUG
#else
  #define vDEBUG_SET_SYS_SPEED(a)
#endif
  ERROR_CODE eEC = ER_OK;
  uint32_t uiRCC_reg = 0;

  if(eCurrent_sys_speed_index == INEEDMD_CPU_SPEED_NOT_SET)
  {
    BIOS_getCpuFreq(&sCPU_freq);
    uiCurrent_sys_speed = (uint32_t)sCPU_freq.lo;

    //determine if the clock source is internal or external
    uiRCC_reg = HWREG(SYSCTL_RCC);
    if((uiRCC_reg & SYSCTL_RCC_MOSCDIS) == SYSCTL_RCC_MOSCDIS)
    {
      //clock source is internal
      //
      //set the sys speed index to the proper value
      if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_FULL_INTERNAL])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_FULL_INTERNAL;
      }
      else if((uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_HALF_INTERNAL]) |
              (uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_HALF_INTERNAL_OSC]))
      {
        //determine if the internal oscillator being used is the PISOC
        if((uiRCC_reg & SYSCTL_RCC_OSCSRC_INT) == SYSCTL_RCC_OSCSRC_INT)
        {
          //clock source is PISOC
          //
          eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_HALF_INTERNAL_OSC;
        }
        else
        {
          //clock source is Main internal
          //
          eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_HALF_INTERNAL;
        }
      }
      else if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_SLOW_INTERNAL])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_SLOW_INTERNAL;
      }
      else if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_REALLY_SLOW])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_REALLY_SLOW;
      }
      else
      {
        vDEBUG_SET_SYS_SPEED("Sys speed SYS HALT, unknown system speed");
        while(1){};
      }
    }
    else
    {
      //Clock source is external
      //
      //set the sys speed index to the proper value
      if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_FULL_EXTERNAL])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_FULL_EXTERNAL;
      }
      else if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_HALF_EXTERNAL])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_HALF_EXTERNAL;
      }
      else if(uiCurrent_sys_speed == uiSystem_Speed_Freq[INEEDMD_CPU_SPEED_QUARTER_EXTERNAL])
      {
        eCurrent_sys_speed_index = INEEDMD_CPU_SPEED_QUARTER_EXTERNAL;
      }
      else
      {
        vDEBUG_SET_SYS_SPEED("Sys speed SYS HALT, unknown system speed");
        while(1){};
      }
    }
  }

  //check if the system speed needs to be chaged if it is not at what is being requested
  if(eCurrent_sys_speed_index != eHow_Fast)
  {
    switch (eHow_Fast)
    {
      case INEEDMD_CPU_SPEED_FULL_EXTERNAL:
        //WARNING - do not use on first board rev!!!!
        //turn on the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, INEEDMD_PORTD_XTAL_ENABLE);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_SET);
        // let it stabalise
        MAP_SysCtlDelay(1000);
        //setting to run on the PLL from the external xtal and switch off the internal oscillator this gives us an 80Mhz clock
//        SysCtlClockSet( SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ );
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_FULL_EXTERNAL");
        break;

      case INEEDMD_CPU_SPEED_HALF_EXTERNAL:
        //WARNING - do not use on first board rev!!!!
        //turn on the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, INEEDMD_PORTD_XTAL_ENABLE);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_SET);
        // let it stabalise
        MAP_SysCtlDelay(1000);
        //setting to run on the PLL from the external xtal and switch off the internal oscillator this gives us an 80Mhz clock
//        SysCtlClockSet( SYSCTL_SYSDIV_5 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_HALF_EXTERNAL");

        break;

      case INEEDMD_CPU_SPEED_QUARTER_EXTERNAL:
        //WARNING - do not use on first board rev!!!!
        //turn on the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, INEEDMD_PORTD_XTAL_ENABLE);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_SET);
        // let it stabalise
        MAP_SysCtlDelay(1000);
        //setting to run on the PLL from the external xtal and switch off the internal oscillator this gives us an 80Mhz clock
//        SysCtlClockSet( SYSCTL_SYSDIV_10 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);(uint32_t)sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_QUARTER_EXTERNAL");

        break;

      case INEEDMD_CPU_SPEED_FULL_INTERNAL:
        //setting to run on the PLL from the internal clock and switch off the external xtal pads and pin this gives us an 80 Mhz clock
//        SysCtlClockSet( SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);
        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_FULL_INTERNAL");

        break;

      case INEEDMD_CPU_SPEED_HALF_INTERNAL:
        //setting to run on the  the internal OSC and switch off the external xtal pads and pin.. Setting the divider to run us at 40Mhz
//        SysCtlClockSet( SYSCTL_SYSDIV_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_HALF_INTERNAL");

        break;

      case INEEDMD_CPU_SPEED_HALF_INTERNAL_OSC:
        //setting to run on the  the internal OSC and switch off the external xtal pads and pin.. Setting the divider to run us at 500khz
//        SysCtlClockSet( SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_HALF_INTERNAL_OSC");

        break;

      case INEEDMD_CPU_SPEED_SLOW_INTERNAL:
        //setting to run on the  the internal OSC and switch off the external xtal pads and pin.. Setting the divider to run us at 500khz
//        SysCtlClockSet( SYSCTL_SYSDIV_8 | SYSCTL_USE_OSC | SYSCTL_OSC_INT4 | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_SLOW_INTERNAL");

        break;

      case INEEDMD_CPU_SPEED_REALLY_SLOW:
        //setting to run on the  the internal OSC and switch off the external xtal pads and pin.. Setting the divider to run us at 30Khz.
        //Communication is't possible.. we are in hibernation
//        SysCtlClockSet( SYSCTL_SYSDIV_1 | SYSCTL_OSC_INT30 | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);

        vDEBUG_SET_SYS_SPEED("Sys speed, INEEDMD_CPU_SPEED_REALLY_SLOW");

        break;

      default:
        //setting the intrnal at full speed as the default.
//        SysCtlClockSet( SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS);
        sCPU_freq.lo = uiSystem_Speed_Freq[eHow_Fast];
        sCPU_freq.hi = 0;
        BIOS_setCpuFreq(&sCPU_freq);
        // switch off the external oscillator
//        MAP_GPIOPinWrite (GPIO_PORTD_BASE, INEEDMD_PORTD_XTAL_ENABLE, 0x00);
        GPIO_write(EK_TM4C123GXL_XTAL_ENABLE, INEEDMD_XTAL_ENABLE_PIN_CLEAR);

        vDEBUG_SET_SYS_SPEED("Sys speed, default");

        break;
    }

    //preserve the system speed
    eCurrent_sys_speed_index = eHow_Fast;
    uiCurrent_sys_speed = uiSystem_Speed_Freq[eHow_Fast];
  }

  return eEC;

#undef vDEBUG_SET_SYS_SPEED
}

/******************************************************************************
* name:
* description:
* param description:
* return value description:
******************************************************************************/
ERROR_CODE eBSP_Set_radio_uart_baud(uint32_t uiBaud_rate_to_set)
{
#define DEBUG_eBSP_Set_radio_uart_baud
#ifdef DEBUG_eBSP_Set_radio_uart_baud
  #define  vDEBUG_BSB_UART_BAUD  vDEBUG
#else
  #define vDEBUG_BSB_UART_BAUD(a)
#endif
  ERROR_CODE eEC = ER_OK;

  ASSERT((uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_57600)   || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_76800)   || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_115200)  || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_230400)  || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_460800)  || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_921600)  || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_1382400) || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_1843200) || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_2764800) || \
         (uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_3686400));

  if(sRadio_UART_handle != NULL)
  {
    UART_close(sRadio_UART_handle);
  }else{/*do nothing*/}

  sRadio_UART_params.baudRate       = uiBaud_rate_to_set;              /*!< Baud rate for UART */

  sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }

  eOSAL_delay(500, NULL);

#ifdef DEBUG_eBSP_Set_radio_uart_baud
  vDEBUG_BSB_UART_BAUD("BSB uart baud set to:");
  if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_57600)
    vDEBUG_BSB_UART_BAUD("57600");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_76800)
    vDEBUG_BSB_UART_BAUD("76800");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_115200)
    vDEBUG_BSB_UART_BAUD("115200");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_230400)
    vDEBUG_BSB_UART_BAUD("230400");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_460800)
    vDEBUG_BSB_UART_BAUD("460800");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_921600)
    vDEBUG_BSB_UART_BAUD("921600");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_1382400)
    vDEBUG_BSB_UART_BAUD("1382400");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_1843200)
    vDEBUG_BSB_UART_BAUD("1843200");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_2764800)
    vDEBUG_BSB_UART_BAUD("2764800");
  else if(uiBaud_rate_to_set == INEEDMD_RADIO_UART_BAUD_3686400)
    vDEBUG_BSB_UART_BAUD("3686400");
  else{/*do nothing*/}
#endif

  return eEC;
#undef vDEBUG_BSB_UART_BAUD
}

/******************************************************************************
* name:
* description:
* param description:
* return value description:
******************************************************************************/
ERROR_CODE eBSP_Get_radio_uart_baud(uint32_t * uiBaud_rate_to_get)
{
#define DEBUG_eBSP_Get_radio_uart_baud
#ifdef DEBUG_eBSP_Get_radio_uart_baud
  #define  vDEBUG_BSB_GET_BAUD  vDEBUG
#else
  #define vDEBUG_BSB_GET_BAUD(a)
#endif
  ERROR_CODE eEC = ER_OK;
  uint32_t uiCurrent_Baud_rate = 0;

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
#ifdef DEBUG
    vDEBUG_BSB_GET_BAUD("Get baud SYS HALT, baud not set");
    while(1){};
#endif
  }
  else
  {
    if(uiCurrent_Baud_rate != sRadio_UART_params.baudRate)
    {
      uiCurrent_Baud_rate = sRadio_UART_params.baudRate;
    }
    *uiBaud_rate_to_get = uiCurrent_Baud_rate;
    eEC = ER_OK;
  }

  return eEC;
#undef vDEBUG_BSB_GET_BAUD
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_Set_radio_uart_to_blocking(void)
{
  ERROR_CODE eEC = ER_FAIL;

  if(sRadio_UART_handle != NULL)
  {
    UART_readCancel(sRadio_UART_handle);
    UART_close(sRadio_UART_handle);
  }else{/*do nothing*/}

  sRadio_UART_params.readMode       = UART_MODE_BLOCKING;              /*!< Mode for all read calls */
  sRadio_UART_params.writeMode      = UART_MODE_BLOCKING;              /*!< Mode for all write calls */
  sRadio_UART_params.readTimeout    = 1000;                            /*!< Timeout for read semaphore */
  sRadio_UART_params.writeTimeout   = 1000;                            /*!< Timeout for write semaphore */
  sRadio_UART_params.readCallback   = NULL;          /*!< Pointer to read callback */
  sRadio_UART_params.writeCallback  = NULL;         /*!< Pointer to write callback */
  sRadio_UART_params.readReturnMode = UART_RETURN_FULL;             /*!< Receive return mode */
  sRadio_UART_params.readDataMode   = UART_DATA_BINARY;                /*!< Type of data being read */
  sRadio_UART_params.writeDataMode  = UART_DATA_BINARY;                /*!< Type of data being written */
  sRadio_UART_params.readEcho       = UART_ECHO_OFF;                   /*!< Echo received data back */
  sRadio_UART_params.baudRate       = INEEDMD_RADIO_UART_BAUD;              /*!< Baud rate for UART */
  sRadio_UART_params.dataLength     = UART_LEN_8;                      /*!< Data length for UART */
  sRadio_UART_params.stopBits       = UART_STOP_ONE;                   /*!< Stop bits for UART */
  sRadio_UART_params.parityType     = UART_PAR_NONE;                   /*!< Parity bit type for UART */

  sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }
  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE  eBSP_Set_radio_uart_to_callback(void)
{
  ERROR_CODE eEC = ER_FAIL;

  if(sRadio_UART_handle != NULL)
  {
    UART_close(sRadio_UART_handle);
  }else{/*do nothing*/}

  UART_Params_init(&sRadio_UART_params);

  sRadio_UART_params.readMode       = UART_MODE_CALLBACK;              /*!< Mode for all read calls */
  sRadio_UART_params.writeMode      = UART_MODE_CALLBACK;              /*!< Mode for all write calls */
  sRadio_UART_params.readTimeout    = BIOS_WAIT_FOREVER;                            /*!< Timeout for read semaphore */
  sRadio_UART_params.writeTimeout    = BIOS_WAIT_FOREVER;                            /*!< Timeout for read semaphore */
  sRadio_UART_params.readCallback   = vIneedMD_radio_read_cb;          /*!< Pointer to read callback */
  sRadio_UART_params.writeCallback  = vIneedMD_radio_write_cb;         /*!< Pointer to write callback */
  sRadio_UART_params.readReturnMode = UART_RETURN_FULL;             /*!< Receive return mode */
  sRadio_UART_params.readDataMode   = UART_DATA_BINARY;                /*!< Type of data being read */
  sRadio_UART_params.writeDataMode  = UART_DATA_BINARY;                /*!< Type of data being written */
  sRadio_UART_params.readEcho       = UART_ECHO_OFF;                   /*!< Echo received data back */
  sRadio_UART_params.baudRate       = INEEDMD_RADIO_UART_BAUD;              /*!< Baud rate for UART */
  sRadio_UART_params.dataLength     = UART_LEN_8;                      /*!< Data length for UART */
  sRadio_UART_params.stopBits       = UART_STOP_ONE;                   /*!< Stop bits for UART */
  sRadio_UART_params.parityType     = UART_PAR_NONE;                   /*!< Parity bit type for UART */

  sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }
  return eEC;
}

//*****************************************************************************
// name: RadioUARTEnable
// description: configures and enables the usart for the BT radio
// param description: none
// return value description: none
//*****************************************************************************
ERROR_CODE  eBSP_RadioUARTEnable(void)
{
  ERROR_CODE eEC = ER_FAIL;


  eEC = eBSP_Set_radio_uart_to_callback();

  return eEC;
}

//*****************************************************************************
// name: eBSP_Radio_Power_On
// description: sets the gpio pin to the radio high to turn on the radio
// param description: none
// return value description:
//*****************************************************************************
ERROR_CODE  eBSP_Radio_Power_On(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_read = 0;

  GPIO_write(EK_TM4C123GXL_RADIO_POWER, INEEDMD_RADIO_ENABLE_PIN_SET);

  uiPin_read = GPIO_read(EK_TM4C123GXL_RADIO_POWER);

  if((uiPin_read & INEEDMD_RADIO_ENABLE_PIN) == INEEDMD_RADIO_ENABLE_PIN_SET)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

//*****************************************************************************
// name: iRadioPowerOff
// description: sets the gpio pin to the radio low to turn the radio off
// param description: none
// return value description: 1 if success
//*****************************************************************************
ERROR_CODE  eBSP_Radio_Power_Off(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_read = 0;

  GPIO_write(EK_TM4C123GXL_RADIO_POWER, INEEDMD_RADIO_ENABLE_PIN_CLEAR);

  uiPin_read = GPIO_read(EK_TM4C123GXL_RADIO_POWER);

  if((uiPin_read & INEEDMD_RADIO_ENABLE_PIN) == INEEDMD_RADIO_ENABLE_PIN_CLEAR)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

/******************************************************************************
* name:
* description:
* param description:
* return value description:
******************************************************************************/
ERROR_CODE  eBSP_Radio_Enable(void)
{
  ERROR_CODE eEC = ER_OK;
  uint32_t uiPin_Read = 0;

  GPIO_write(EK_TM4C123GXL_RADIO_RESET, INEEDMD_RADIO_RESET_PIN_CLEAR);

  uiPin_Read = GPIO_read(EK_TM4C123GXL_RADIO_RESET);

  if((uiPin_Read & INEEDMD_RADIO_RESET_PIN) == INEEDMD_RADIO_RESET_PIN_CLEAR)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

/******************************************************************************
* name:
* description:
* param description:
* return value description:
******************************************************************************/
ERROR_CODE  eBSP_Radio_Disable(void)
{
  ERROR_CODE eEC = ER_OK;
  uint32_t uiPin_value = 0;


  GPIO_write(EK_TM4C123GXL_RADIO_RESET, INEEDMD_RADIO_RESET_PIN_SET);

  uiPin_value = GPIO_read(EK_TM4C123GXL_RADIO_RESET);

  if((uiPin_value & INEEDMD_RADIO_RESET_PIN) == INEEDMD_RADIO_RESET_PIN_SET)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

/******************************************************************************
* name:
* description:
* param description:
* return value description:
******************************************************************************/
ERROR_CODE  eBSP_Radio_Reset(void)
{
  ERROR_CODE eEC = ER_OK;

  //exert the radio rest pin
  eBSP_Radio_Disable();

  //delay for 100ms
  eOSAL_delay(100, NULL);

  //de-exert,sets it low, reset pin
  eBSP_Radio_Enable();

  return eEC;
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Set_radio_to_cmnd_mode(void)
{
//#define DEBUG_eSet_radio_to_cmnd_mode
#ifdef DEBUG_eSet_radio_to_cmnd_mode
  #define  SND_BUFF_SZ  32
  #define  vDEBUG_BRD_SET_RDIO_CMND_MODE  vDEBUG
  char cDbg_snd_buff[SND_BUFF_SZ];
  uint32_t uiGPIO_rd = 0;
#else
  #define vDEBUG_BRD_SET_RDIO_CMND_MODE(a)
#endif
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_value = 0;

  GPIO_write(EK_TM4C123GXL_RADIO_CMND_MODE, INEEDMD_RADIO_CMND_PIN_SET);

  uiPin_value =  GPIO_read(EK_TM4C123GXL_RADIO_CMND_MODE);
  if(uiPin_value != INEEDMD_RADIO_CMND_PIN_SET)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }
#ifdef DEBUG_eSet_radio_to_cmnd_mode
  memset(cDbg_snd_buff, 0x00, SND_BUFF_SZ);
  uiGPIO_rd = MAP_GPIOPinRead(INEEDMD_RADIO_PORT, INEEDMD_RADIO_CMND_PIN);
  snprintf(cDbg_snd_buff, SND_BUFF_SZ, "Set rdio cmnd md, %.4x", uiGPIO_rd);
  vDEBUG_BRD_SET_RDIO_CMND_MODE(cDbg_snd_buff);
#endif

  return eEC;
#undef  vDEBUG_BRD_SET_RDIO_CMND_MODE
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eIs_radio_in_cmnd_mode(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_Read = 0;

  uiPin_Read = MAP_GPIOPinRead(INEEDMD_GPIO_CMND_PORT, INEEDMD_RADIO_CMND_PIN);

  if((uiPin_Read & INEEDMD_RADIO_CMND_PIN) == INEEDMD_RADIO_CMND_PIN)
  {
    eEC = ER_TRUE;
  }
  else
  {
    eEC = ER_FALSE;
  }

  return eEC;
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Set_radio_to_data_mode(void)
{
//#define DEBUG_eSet_radio_to_data_mode
#ifdef DEBUG_eSet_radio_to_data_mode
  #define  SND_BUFF_SZ  32
  #define  vDEBUG_BRD_SET_RDIO_DTA_MODE  vDEBUG
  char cDbg_snd_buff[SND_BUFF_SZ];
  uint32_t uiGPIO_rd = 0;
#else
  #define vDEBUG_BRD_SET_RDIO_DTA_MODE(a)
#endif
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_value = 0;

//  MAP_GPIOPinWrite(INEEDMD_GPIO_CMND_PORT, INEEDMD_RADIO_CMND_PIN, INEEDMD_RADIO_CMND_PIN_CLEAR);
  GPIO_write(EK_TM4C123GXL_RADIO_CMND_MODE, INEEDMD_RADIO_CMND_PIN_CLEAR);

  uiPin_value =  GPIO_read(EK_TM4C123GXL_RADIO_CMND_MODE);
  if(uiPin_value != INEEDMD_RADIO_CMND_PIN_CLEAR)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }
#ifdef DEBUG_eSet_radio_to_data_mode
  memset(cDbg_snd_buff, 0x00, SND_BUFF_SZ);
  uiGPIO_rd = MAP_GPIOPinRead(INEEDMD_RADIO_PORT, INEEDMD_RADIO_CMND_PIN);
  snprintf(cDbg_snd_buff, SND_BUFF_SZ, "Set rdio dta md, %.4x", uiGPIO_rd);
  vDEBUG_BRD_SET_RDIO_DTA_MODE(cDbg_snd_buff);
#endif

  return eEC;
#undef vDEBUG_BRD_SET_RDIO_DTA_MODE
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eUsing_radio_uart_dma(void)
{
  ERROR_CODE eEC = ER_FAIL;

  if(USE_RADIO_UART_DMA == true)
  {
    eEC = ER_TRUE;
  }
  else
  {
    eEC = ER_FALSE;
  }

  return eEC;
}

ERROR_CODE  eBSP_Radio_send_byte(uint8_t * uiSend_Byte)
{
  ERROR_CODE eEC = ER_FAIL;
  int iSent_bytes = 0;

  iSent_bytes = UART_write(sRadio_UART_handle, uiSend_Byte, 1);

  if(iSent_bytes == UART_ERROR)
  {
    eEC = ER_FAIL;
  }
  else if(iSent_bytes == 0)
  {
    eEC = ER_TIMEOUT;
  }
  else if(iSent_bytes == 1)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Radio_send_frame(uint8_t *cSend_frame, uint16_t uiFrame_len)
{
  ERROR_CODE eEC = ER_FAIL;
  int iSent_bytes = 0;

  iSent_bytes = UART_write(sRadio_UART_handle, cSend_frame, uiFrame_len);

  if(iSent_bytes == UART_ERROR)
  {
    eEC = ER_FAIL;
  }
  else if(iSent_bytes == 0)
  {
    eEC = ER_TIMEOUT;
  }
  else if(iSent_bytes == uiFrame_len)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

ERROR_CODE  eBSP_Radio_send_frame_halt(void)
{
  ERROR_CODE eEC = ER_FAIL;

  UART_writeCancel(sRadio_UART_handle);

  eEC = ER_OK;

  return eEC;
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Radio_rcv_string(char *cRcv_string, uint16_t uiBuff_size)
{
  ERROR_CODE eEC = ER_FAIL;
  int i = 0;

  i = UART_read(sRadio_UART_handle, cRcv_string, uiBuff_size);

  if(i == UART_ERROR)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }
  return eEC;

}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Radio_rcv_char(char *cRcv_char)
{
  ERROR_CODE eEC = ER_FAIL;
  UART_Params sPrev_Radio_UART_params;
  int i = sizeof(UART_Params);

  memcpy(&sPrev_Radio_UART_params, &sRadio_UART_params, i);

  if(sRadio_UART_handle != NULL)
  {
    UART_close(sRadio_UART_handle);
  }else{/*do nothing*/}

  UART_Params_init(&sRadio_UART_params);

  sRadio_UART_params.readMode       = UART_MODE_BLOCKING;              /*!< Mode for all read calls */
  sRadio_UART_params.writeMode      = UART_MODE_BLOCKING;              /*!< Mode for all write calls */
  sRadio_UART_params.readTimeout    = 100;                            /*!< Timeout for read semaphore */
  sRadio_UART_params.writeTimeout   = 1000;                            /*!< Timeout for write semaphore */
  sRadio_UART_params.readCallback   = NULL;          /*!< Pointer to read callback */
  sRadio_UART_params.writeCallback  = NULL;         /*!< Pointer to write callback */
  sRadio_UART_params.readReturnMode = UART_RETURN_FULL;             /*!< Receive return mode */
  sRadio_UART_params.readDataMode   = UART_DATA_BINARY;                /*!< Type of data being read */
  sRadio_UART_params.writeDataMode  = UART_DATA_BINARY;                /*!< Type of data being written */
  sRadio_UART_params.readEcho       = UART_ECHO_OFF;                   /*!< Echo received data back */
  sRadio_UART_params.baudRate       = INEEDMD_RADIO_UART_BAUD;              /*!< Baud rate for UART */
  sRadio_UART_params.dataLength     = UART_LEN_8;                      /*!< Data length for UART */
  sRadio_UART_params.stopBits       = UART_STOP_ONE;                   /*!< Stop bits for UART */
  sRadio_UART_params.parityType     = UART_PAR_NONE;                   /*!< Parity bit type for UART */

  sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    i = UART_read(sRadio_UART_handle, cRcv_char, 1);

    eOSAL_delay(1, NULL);

    if(i == UART_ERROR)
    {
      eEC = ER_FAIL;
    }
    else if(i == 0)
    {
      eEC = ER_TIMEOUT;
    }
    else
    {
      eEC = ER_OK;
    }

    memcpy(&sRadio_UART_params, &sPrev_Radio_UART_params, sizeof(UART_Params));
    UART_close(sRadio_UART_handle);

    sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

    if(sRadio_UART_handle == NULL)
    {
      eEC = ER_FAIL;
    }
  }

  return eEC;
}

ERROR_CODE  eBSP_Radio_rcv_frame(uint8_t * cRcv_frame, uint32_t uiFrame_len)
{
  ERROR_CODE eEC = ER_FAIL;
  int iRcvd_bytes = 0;

  iRcvd_bytes = UART_read(sRadio_UART_handle, cRcv_frame, uiFrame_len);

  if(iRcvd_bytes == UART_ERROR)
  {
    eEC = ER_FAIL;
  }
  else if(iRcvd_bytes == 0)
  {
    eEC = ER_TIMEOUT;
  }
  else if(iRcvd_bytes == uiFrame_len)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

ERROR_CODE eBSP_Radio_rcv_frame_halt(void)
{
  ERROR_CODE eEC = ER_FAIL;

  UART_readCancel(sRadio_UART_handle);
  eEC = ER_OK;

  return eEC;
}

//*****************************************************************************
// name: eRadio_clear_rcv_buffer
// description: performs a non-blocking receive on the radio UART untill there
//   is no more data to receive. This function has a timeout which is its
//   primary method of determining if there is any more data to receive.
// param description:
// return value description: returns an error code
//                           ER_OK     - this is an invalid error code and should not be returned
//                           ER_NODATA - there was never any data on the UART to receive
//                           ER_CLEAR  - there was data on the UART and it was cleared
//
//*****************************************************************************
ERROR_CODE  eBSP_Radio_clear_rcv_buffer(void)
{
//#define DEBUG_eRadio_clear_rcv_buffer
#ifdef DEBUG_eRadio_clear_rcv_buffer
  #define  vDEBUG_RDIO_RCV_CLR  vDEBUG
#else
  #define vDEBUG_RDIO_RCV_CLR(a)
#endif
  ERROR_CODE eEC = ER_OK;
  uint8_t uiRcv_byte = 0;
  bool bWas_data = false;
  UART_Params sPrev_Radio_UART_params;

  int i = sizeof(UART_Params);

  memcpy(&sPrev_Radio_UART_params, &sRadio_UART_params, i);

  if(sRadio_UART_handle != NULL)
  {
    UART_close(sRadio_UART_handle);
  }else{/*do nothing*/}

  UART_Params_init(&sRadio_UART_params);

  sRadio_UART_params.readMode       = UART_MODE_BLOCKING;              /*!< Mode for all read calls */
  sRadio_UART_params.writeMode      = UART_MODE_BLOCKING;              /*!< Mode for all write calls */
  sRadio_UART_params.readTimeout    = 100;                            /*!< Timeout for read semaphore */
  sRadio_UART_params.writeTimeout   = 1000;                            /*!< Timeout for write semaphore */
  sRadio_UART_params.readCallback   = NULL;          /*!< Pointer to read callback */
  sRadio_UART_params.writeCallback  = NULL;         /*!< Pointer to write callback */
  sRadio_UART_params.readReturnMode = UART_RETURN_FULL;             /*!< Receive return mode */
  sRadio_UART_params.readDataMode   = UART_DATA_BINARY;                /*!< Type of data being read */
  sRadio_UART_params.writeDataMode  = UART_DATA_BINARY;                /*!< Type of data being written */
  sRadio_UART_params.readEcho       = UART_ECHO_OFF;                   /*!< Echo received data back */
  sRadio_UART_params.baudRate       = INEEDMD_RADIO_UART_BAUD;              /*!< Baud rate for UART */
  sRadio_UART_params.dataLength     = UART_LEN_8;                      /*!< Data length for UART */
  sRadio_UART_params.stopBits       = UART_STOP_ONE;                   /*!< Stop bits for UART */
  sRadio_UART_params.parityType     = UART_PAR_NONE;                   /*!< Parity bit type for UART */

  sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

  if(sRadio_UART_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
    while(1)
    {
      //get any data on the radio uart
      UART_read(sRadio_UART_handle, &uiRcv_byte, 1);

      eOSAL_delay(10, NULL);

      if(uiRcv_byte == 0x00)
      {
        break;
      }
      else
      {
        uiRcv_byte = 0x00;
        bWas_data = true;
      }
    }

    //check if ANY data was received and set the proper error code
    if(bWas_data == true)
    {
      vDEBUG_RDIO_RCV_CLR("Rdio rcv clr, there was rcv data to clear");
      eEC = ER_CLEAR;
    }
    else
    {
      vDEBUG_RDIO_RCV_CLR("Rdio rcv clr, no rcv data to clear");
      eEC = ER_OK;
    }

    memcpy(&sRadio_UART_params, &sPrev_Radio_UART_params, sizeof(UART_Params));
    UART_close(sRadio_UART_handle);

    sRadio_UART_handle = UART_open(INEEDMD_RADIO_UART_INDEX, &sRadio_UART_params);

    if(sRadio_UART_handle == NULL)
    {
      eEC = ER_FAIL;
    }
  }

  return eEC;
#undef vDEBUG_RDIO_RCV_CLR
}

//*****************************************************************************
// name: eGet_Radio_CTS_status
// description:
// param description:
// return value description: returns an error code
//                           ER_FAIL    - unknown return value, should not occure
//                           ER_TRUE    - UART CTS is set
//                           ER_FALSE   - UART CTS is not set
//*****************************************************************************
ERROR_CODE  eBSP_Get_Radio_CTS_status(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiModem_status_get = 0;

  uiModem_status_get = HWREG(INEEDMD_RADIO_UART + UART_O_FR);

  if((uiModem_status_get & UART_INPUT_CTS) == UART_INPUT_CTS)
  {
    eEC = ER_TRUE;
  }
  else
  {
    eEC = ER_FALSE;
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_Get_Radio_CD_status(void)
{
  ERROR_CODE eEC = ER_FAIL;

  uint32_t uiPin_value = 0;

  uiPin_value = GPIO_read(EK_TM4C123GXL_RADIO_CD);

  if((uiPin_value & INEEDMD_RADIO_CD_PIN) == INEEDMD_RADIO_CD_PIN_SET)
  {
    eEC = ER_SET;
  }
  else
  {
    eEC = ER_NOT_SET;
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_Get_Radio_low_bat_status(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_value = 0;

  uiPin_value = GPIO_read(EK_TM4C123GXL_RADIO_LOW_BATT);

  if((uiPin_value & INEEDMD_RADIO_LOW_BAT_PIN) == INEEDMD_RADIO_LOW_BAT_PIN_SET)
  {
    eEC = ER_SET;
  }
  else
  {
    eEC = ER_NOT_SET;
  }

  return eEC;
}

//*****************************************************************************
// name:
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE  eBSP_USB_is_physical_connection(void)
{
  ERROR_CODE eEC = ER_NOT_CONNECTED;
  uint32_t uiUSB_conn_pin_status = 0;

  uiUSB_conn_pin_status = GPIO_read(EK_TM4C123GXL_USB_DETECT);
  if(INEEDMD_USB_DET_PIN_SET == uiUSB_conn_pin_status)
  {
    eEC = ER_CONNECTED;
  }
  else
  {
    eEC = ER_NOT_CONNECTED;
  }

  return eEC;
}

/******************************************************************************
* name: vBSP_USB_DFU
* description:
* param description: void
*
* return value description: void - Function WILL NOT return
******************************************************************************/
void vBSP_USB_DFU(void)
{
  uint32_t ui32SysClock = 0;
  uint32_t ui32Addr = 0;

  ROM_IntMasterDisable();
  ROM_SysTickIntDisable();
  ROM_SysTickDisable();
  ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);
  ui32SysClock = ROM_SysCtlClockGet();
  ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
  ROM_GPIOPinTypeUSBAnalog(GPIO_PORTD_BASE, GPIO_PIN_4 | GPIO_PIN_5);
  ROM_SysTickPeriodSet(ROM_SysCtlClockGet() / 100);
  HWREG(NVIC_DIS0) = 0xffffffff;
  HWREG(NVIC_DIS1) = 0xffffffff;
  HWREG(NVIC_DIS2) = 0xffffffff;
  HWREG(NVIC_DIS3) = 0xffffffff;
  HWREG(NVIC_DIS4) = 0xffffffff;

  for(ui32Addr = NVIC_PRI0; ui32Addr <= NVIC_PRI34; ui32Addr+=4)
  {
    HWREG(ui32Addr) = 0;
  }
  HWREG(NVIC_SYS_PRI1) = 0;
  HWREG(NVIC_SYS_PRI2) = 0;
  HWREG(NVIC_SYS_PRI3) = 0;
  ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
  ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_USB0);
  ROM_SysCtlUSBPLLEnable();
  ROM_SysCtlDelay(ui32SysClock*2 / 3);
  ROM_IntMasterEnable();
  ROM_UpdateUSB(0);
  vDEBUG_ASSERT("vBSP_USB_DFU Failure!", 0);
}

/******************************************************************************
* name: eBSP_ADC_Hard_Reset
* description: do a hardware reset by pulling reset low
* param description:
*
* return value description: ERROR_CODE - ER_OK: reset successful
*                                      - ER_FAIL: reset fail
******************************************************************************/
ERROR_CODE eBSP_ADC_Hard_Reset(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_Read;
  //toggle reset pin
//  GPIOPinWrite(GPIO_PORTA_BASE, INEEDMD_PORTA_ADC_RESET_OUT_PIN, 0x00);
  GPIO_write(EK_TM4C123GXL_ADC_RESET, INEEDMD_ADC_RESET_PIN_CLEAR);
  uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_RESET);
  if((uiPin_Read & INEEDMD_ADC_RESET_PIN) == INEEDMD_ADC_RESET_PIN_CLEAR)
  {
    eOSAL_delay(3, NULL);

    //  GPIOPinWrite(GPIO_PORTA_BASE, INEEDMD_PORTA_ADC_RESET_OUT_PIN, INEEDMD_PORTA_ADC_RESET_OUT_PIN);
    GPIO_write(EK_TM4C123GXL_ADC_RESET, INEEDMD_ADC_RESET_PIN_SET);
    uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_RESET);
    if((uiPin_Read & INEEDMD_ADC_RESET_PIN) == INEEDMD_ADC_RESET_PIN_SET)
    {
      eEC = ER_OK;
      eOSAL_delay(3, NULL);
    }
    else
    {
      eEC = ER_FAIL;
    }
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

ERROR_CODE eBSP_ADC_Reset(bool bReset)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_Read;

  if(bReset == true)
  {
    GPIO_write(EK_TM4C123GXL_ADC_RESET, INEEDMD_ADC_RESET_PIN_CLEAR);

    uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_RESET);
    if((uiPin_Read & INEEDMD_ADC_RESET_PIN) == INEEDMD_ADC_RESET_PIN_CLEAR)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }
  }
  else
  {
    GPIO_write(EK_TM4C123GXL_ADC_RESET, INEEDMD_ADC_RESET_PIN_SET);

    uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_RESET);
    if((uiPin_Read & INEEDMD_ADC_RESET_PIN) == INEEDMD_ADC_RESET_PIN_SET)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }
  }

  return eEC;
}

/******************************************************************************
* name: eBSP_ADC_Start
* description: Starts or stops the ADC depending on the parameter
* param description: bool - true: start the ADC
*                         - false: stop the ADC
* return value description: ERROR_CODE - ER_OK: pin to adc was set/cleared
*                                      - ER_FAIL: pin to adc was not set/cleared
******************************************************************************/
ERROR_CODE  eBSP_ADC_Start(bool bStart)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiPin_Read;

  if(bStart == true)
  {
    GPIO_write(EK_TM4C123GXL_ADC_START, INEEDMD_ADC_START_PIN_SET);

    uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_START);
    if((uiPin_Read & INEEDMD_ADC_START_PIN) == INEEDMD_ADC_START_PIN_SET)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }
  }
  else
  {
    GPIO_write(EK_TM4C123GXL_ADC_START, INEEDMD_ADC_START_PIN_CLEAR);

    uiPin_Read = GPIO_read(EK_TM4C123GXL_ADC_START);
    if((uiPin_Read & INEEDMD_ADC_START_PIN) == INEEDMD_ADC_START_PIN_CLEAR)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }
  }

  return eEC;
}

ERROR_CODE eBSP_ADC_Select(bool bSelect)
{
  ERROR_CODE eEC = ER_OK;

  if(bSelect == true)
  {
//    GPIO_write(EK_TM4C123GXL_ADC_nCS, INEEDMD_ADC_nCS_PIN_SET);
    GPIO_write(EK_TM4C123GXL_ADC_nCS, INEEDMD_ADC_nCS_PIN_CLEAR);
  }
  else
  {
//    GPIO_write(EK_TM4C123GXL_ADC_nCS, INEEDMD_ADC_nCS_PIN_CLEAR);
    GPIO_write(EK_TM4C123GXL_ADC_nCS, INEEDMD_ADC_nCS_PIN_SET);
  }

  return eEC;
}

/******************************************************************************
* name: eBSP_ADC_Power
* description: ads1198 power on sequence. toggles pwdn and reset, waits for device to start
*              wakes with continuous conversions enabled
*              call INEEDMD_ADC_Stop_Continuous_Conv or send SDATAC before attempting to read/write registers
* param description: bool - true: power on the ADC
*                         - false: power off the ADC
* return value description: ERROR_CODE - ER_OK
*                                      - ER_FAIL
******************************************************************************/
ERROR_CODE  eBSP_ADC_Power(bool bPower)
{
  ERROR_CODE eEC = ER_FAIL;

  if(bPower == true)
  {
    //enable ADC power
    GPIO_write(EK_TM4C123GXL_ADC_POWER, INEEDMD_ADC_PWR_PIN_SET);

    eEC = ER_OK;

  }
  else
  {

    //Disable ADC power
    GPIO_write(EK_TM4C123GXL_ADC_POWER, INEEDMD_ADC_PWR_PIN_CLEAR);
    eEC = ER_FAIL;

  }

  return eEC;
}

/******************************************************************************
* name: eBSP_ADC_Continuous_Conv
* description: sets continuous conversions.
* for false: if START pin is high or a START command received (if START pin is low)
*  conversions are put into outbound Tx(MISO) FIFO
*  when a RDATA command is received
*  Clock data out using ineedmd_adc_Receive_Conversion
*
* for true:If start pin is high or START command is received
*  conversions are automatically put into outbound Tx(MISO) FIFO when ready (DRDY goes low)
*  use INEEDMD_ADC_Receive_Conversion so shift data through MISO
* param description: bool - true:
*                         - false:
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Continuous_Conv(bool bConversions)
{
  ERROR_CODE eEC = ER_FAIL;

  //check if conversions should be started
  if(bConversions == true)
  {
    eEC = eBSP_ADC_Data_command(ADS1198_RDATAC);
  }
  else
  {
    eEC = eBSP_ADC_Data_command(ADS1198_SDATAC);
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Data_command(uint8_t uiCommand)
{
  ERROR_CODE eEC = ER_FAIL;
  SPI_Transaction tSPI_transaction;
  bool bDid_spi_trans;

  //check if the command to send to the ADC is valid
  if((uiCommand == ADS1198_RDATAC) |\
     (uiCommand == ADS1198_SDATAC) |\
     (uiCommand == ADS1198_RDATA))
  {

    tSPI_transaction.count = sizeof(uiCommand);
    tSPI_transaction.txBuf = (void *)&uiCommand;
    tSPI_transaction.rxBuf = NULL;

    eBSP_ADC_Select(true);

    bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
    if(bDid_spi_trans == true)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }

    eBSP_ADC_Select(false);
  }
  else
  {
    eEC = ER_COMMAND;
  }


  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Data_frame_read(uint8_t *pData, uint16_t uiFrameLength)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;
  uint8_t txData = 0;
  uint8_t rxData = 0;
  int i = 0;

  if(uiFrameLength < 1)
  {
    return ER_FAIL;
  }

  //Set the transfer to send a NOP to read out the register value
  txData = ADS1198_NOP;

  tSPI_transaction.txBuf = &txData;
  tSPI_transaction.count = sizeof(rxData);
  tSPI_transaction.rxBuf = &rxData;

  eBSP_ADC_Select(true);
  //read the data from the ads and store it into the data frame

  for(i = 0; i < uiFrameLength; i++)
  {
    bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
    if(bDid_spi_trans == true)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_RECEIVE;
    }

    if(eEC == ER_OK)
    {
      pData[i] = rxData;
      continue;
    }
    else
    {
      break;
    }

  }
  eBSP_ADC_Select(false);

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Data_single_read(uint8_t *pData)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;
  uint8_t txData = 0;
  uint8_t rxData = 0;

  //Set the transfer to send a NOP to read out the register value
  txData = ADS1198_NOP;

  tSPI_transaction.txBuf = &txData;
  tSPI_transaction.count = sizeof(rxData);
  tSPI_transaction.rxBuf = &rxData;

  //Chip select the ADC
  eBSP_ADC_Select(true);

  //read out the register value
  bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
  if(bDid_spi_trans == true)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_RECEIVE;
  }

  //De-Chip select the ADC
  eBSP_ADC_Select(false);

  *pData = rxData;

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Data_ADS_read(uint8_t * pData, uint16_t uiNum_Bytes)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;
  uint8_t txData = 0;
  

  //Set the transfer to send a NOP to read out the register value
  txData = ADS1198_NOP;

//  tSPI_transaction.txBuf = NULL;
  tSPI_transaction.txBuf = &txData;
  tSPI_transaction.count = uiNum_Bytes;
  tSPI_transaction.rxBuf = pData;

  //Chip select the ADC
  eBSP_ADC_Select(true);

  //read out the register value
  bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
  if(bDid_spi_trans == true)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_RECEIVE;
  }

  //De-Chip select the ADC
  eBSP_ADC_Select(false);

  return eEC;
}

//********************************************************************************
//returns the contents of the register specified by "address"
//
//see ads1198.h for register definitions
//
//ensure device is not in continuous conversion mode
//using INEEDMD_ADC_Stop_Continuous_Conv() prior to calling this function
//********************************************************************************
ERROR_CODE eBSP_ADC_Register_Read(uint8_t address, uint8_t * uiRX_Data)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;

  uint8_t txData[2];
  uint8_t rxData;

  txData[0] = (RREG | address);   //mask with read command
  txData[1] = ADC_SPI_BYTES_TO_READ(1);

  tSPI_transaction.count = sizeof(txData);
  tSPI_transaction.txBuf = (void *)txData;
  tSPI_transaction.rxBuf = NULL;

  //Chip select the ADC
  eBSP_ADC_Select(true);

  //send the read register command
  bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
  if(bDid_spi_trans == true)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_TRANSMIT;
  }

  //check if the read register command was transmitted
  if(eEC == ER_OK)
  {
    //the read register command was sent, prepare to read the register
    //

    //Set the transfer to send a NOP to read out the register value
    txData[0] = ADS1198_NOP;
    rxData = 0x00;

    tSPI_transaction.txBuf = (void *)txData;
    tSPI_transaction.count = sizeof(rxData);
    tSPI_transaction.rxBuf = &rxData;

    //read out the register value
    bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
    if(bDid_spi_trans == true)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_RECEIVE;
    }

    //De-Chip select the ADC
    eBSP_ADC_Select(false);

    * uiRX_Data = rxData;
  }else{/*do nothing*/}

  return eEC;
}

//********************************************************************************
//writes the value to register address in ads1198
//
//see ads1198.h for register definitions
//
//ensure device is not in continuous conversion mode
//using INEEDMD_ADC_Stop_Continuous_Conv() prior to calling this function
//********************************************************************************
ERROR_CODE eBSP_ADC_Register_Write(uint8_t address, uint8_t value)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;

  uint8_t txData[3];

  uint8_t uiReg_verify = 0;

  txData[0] = (WREG | address);   //mask with read command
  txData[1] = 0x00;        //write n + 1 bytes (1)

  eBSP_ADC_Register_Read(address, &txData[2]);
  txData[2] |= value;                //mask with new value

  tSPI_transaction.count = sizeof(txData);
  tSPI_transaction.txBuf = (void *)txData;
  tSPI_transaction.rxBuf = NULL;

  eBSP_ADC_Select(true);

  //send write command followed by data
  bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
  if(bDid_spi_trans == true)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_TRANSMIT;
  }

  eBSP_ADC_Select(false);

  if(eEC == ER_OK)
  {
    eBSP_ADC_Register_Read(address, &uiReg_verify);

    if((uiReg_verify & value) == value)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_FAIL;
    }
  }else{/*do nothing*/}

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_Register_Clear(uint8_t address, uint8_t value)
{
  ERROR_CODE eEC = ER_FAIL;
  bool bDid_spi_trans = false;
  SPI_Transaction tSPI_transaction;
  uint8_t txData[3];
  uint8_t uiReg_val = 0;

  eBSP_ADC_Register_Read(address, &uiReg_val);

  //check if any of the value bits to clear are set
  if(uiReg_val & value)
  {
    //Some of the bits to clear are set and need to be cleared
    //
    txData[0] = (WREG | address);   //mask with read command
    txData[1] = ADC_SPI_BYTES_TO_WRITE(1);

    uiReg_val &= ~value;
    txData[2] = uiReg_val;

    tSPI_transaction.count = sizeof(txData);
    tSPI_transaction.txBuf = (void *)txData;
    tSPI_transaction.rxBuf = NULL;

    eBSP_ADC_Select(true);

    //send write command followed by data
    bDid_spi_trans = SPI_transfer(tSPI_ADC_handle, &tSPI_transaction);
    if(bDid_spi_trans == true)
    {
      eEC = ER_OK;
    }
    else
    {
      eEC = ER_TRANSMIT;
    }

    eBSP_ADC_Select(false);

    //check if the spi transfer was successful
    if(eEC == ER_OK)
    {
      //verify the new value written to the register
      eBSP_ADC_Register_Read(address, &uiReg_val);

      if(uiReg_val & value)
      {
        //the bits to clear were not cleared
        eEC = ER_FAIL;
      }
      else
      {
        eEC = ER_OK;
      }
    }
  }
  else
  {
    //The bits to clear are already cleared
    eEC = ER_OK;
  }

  return eEC;
}

/******************************************************************************
* name: eBSP_ADC_SPI_Enable
* description: enables the SPI to the ADC
* param description:
*
* return value description: ERROR_CODE - ER_OK
*                                      - ER_FAIL
******************************************************************************/
ERROR_CODE eBSP_ADC_SPI_Enable(void)
{
  ERROR_CODE eEC = ER_FAIL;;

  SPI_Params_init(&tSPI_ADC_params);

  tSPI_ADC_params.bitRate = ADC_SPI_BITRATE_4M;
  tSPI_ADC_params.dataSize = 8;
  tSPI_ADC_params.mode = SPI_MASTER;
  tSPI_ADC_params.transferMode = SPI_MODE_BLOCKING;
  tSPI_ADC_params.frameFormat = SPI_POL0_PHA1;

  tSPI_ADC_handle = SPI_open(EK_TM4C123GXL_SPI_ADC, &tSPI_ADC_params);

  if(tSPI_ADC_handle == NULL)
  {
    eEC = ER_FAIL;
  }
  else
  {
    eEC = ER_OK;
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE  eBSP_ADC_temperature_init (void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiRef = 0;

  //switch off the sequencer so the configuration can be made
  ADCSequenceDisable(TEMPERATURE_ADC, 3);
  //set the ADC reference to internal 3V
  ADCReferenceSet(TEMPERATURE_ADC, ADC_REF_INT);
  //set the ADC to be triggered by the processor asking for a conversion not a timer.  This reduces reduces interupts
  //at the expence of some processor cycles  The interupt will only be used in the ADC block so doesn't need to be registered
  ADCSequenceConfigure(TEMPERATURE_ADC, 3, ADC_TRIGGER_PROCESSOR, 0);
  //set the source to ..
  //    ADC_CTL_TS- Temperature channel
  //    ADC_CTL_IE - generate an interupt wen complete .. needed for the wait function
  //    ADC_CTL_END - This is the last step in the process.
  ADCSequenceStepConfigure(TEMPERATURE_ADC, 3, 0, ADC_CTL_TS | ADC_CTL_END );
  //clear the interupt generated by the configureation
  ADCIntClear(TEMPERATURE_ADC, 3);
  // enable the sequencer for action
  ADCSequenceEnable(TEMPERATURE_ADC, 3);

  uiRef = ADCReferenceGet(TEMPERATURE_ADC);
  if(uiRef == ADC_REF_INT)
  {
    eEC = ER_OK;
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE  eBSP_ADC_temperature_read (uint32_t * pData)
{
  ERROR_CODE eEC = ER_FAIL;

  // ask for a conversion
  ADCProcessorTrigger(TEMPERATURE_ADC,3);
  //wait for it to be done
  while(ADCBusy(TEMPERATURE_ADC)){}
  eEC = ER_OK;
  //finally get the data
  ADCSequenceDataGet(TEMPERATURE_ADC, 3, pData);

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_ADC_batt_volt_init(void)
{
  ERROR_CODE eEC = ER_FAIL;

  uint32_t uiRef = 0;

  //switch off the sequencer so the configuration can be made

  ADCSequenceDisable(BATTERY_ADC, 3);

  //set the ADC reference to internal 3V
  ADCReferenceSet(BATTERY_ADC, ADC_REF_INT);
  //set the clocks to the default .  final colock speed must be at 16Mhz
  ADCClockConfigSet(BATTERY_ADC,ADC_CLOCK_SRC_PIOSC | ADC_CLOCK_RATE_FULL, 1);
  //set the ADC to be triggered by the processor asking for a conversion not a timer.  This reduces reduces interupts
  //at the expence of some processor cycles  The interupt will only be used in the ADC block so doesn't need to be registered
  ADCSequenceConfigure(BATTERY_ADC, 3, ADC_TRIGGER_PROCESSOR, 0);
  //set the source to ..
  //    ADC_CTL_TS- Temperature channel
  //    ADC_CTL_IE - generate an interupt wen complete .. needed for the wait function
  //    ADC_CTL_END - This is the last step in the process.
  ADCSequenceStepConfigure(BATTERY_ADC, 3, 0, ADC_CTL_CH3 | ADC_CTL_END );
  // set up the oversampling to improve accuracy

  ADCHardwareOversampleConfigure(BATTERY_ADC, 32);

  //clear the interupt generated by the configureation
  ADCIntClear(BATTERY_ADC, 3);
  // enable the sequencer for action
  ADCSequenceEnable(BATTERY_ADC, 3);

  uiRef = ADCReferenceGet(BATTERY_ADC);
  if(uiRef == ADC_REF_INT)
  {
    eEC = ER_OK;
  }

  return eEC;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE  eBSP_ADC_batt_volt_read   (uint32_t * pData)
{
  ERROR_CODE eEC = ER_FAIL;
  // ask for a conversion
  ADCProcessorTrigger(BATTERY_ADC,3);
  //wait for it to be done
  while(ADCBusy(BATTERY_ADC)){}
  eEC = ER_OK;
  //finally get the data
  ADCSequenceDataGet(BATTERY_ADC, 3, pData);
  return eEC;
}

//*****************************************************************************
// name: eMaster_int_enable
// description:
// param description:
// return value description:
//*****************************************************************************
ERROR_CODE eBSP_Master_int_enable(void)
{
  ERROR_CODE eEC = ER_OK;
  MAP_IntMasterEnable();
  return eEC;
}

///******************************************************************************
//* name: eMaster_int_disable
//* description:
//* param description:
//* return value description:
//******************************************************************************/
ERROR_CODE eBSP_Master_int_disable(void)
{
  ERROR_CODE eEC = ER_OK;
  MAP_IntMasterDisable();
  return eEC;
}

/******************************************************************************
* name: iHW_delay
* description: performs a blocking hardware based delay. the delay is in 1ms
*  "chunks". Only to be used before BIOS start.
* param description:  uint32_t number of 1ms cycles to delay
* return value description: the number of cycles delayed
******************************************************************************/
int
iHW_delay(uint32_t uiDelay)
{
  int i = 0;
  uint32_t uiHW_delay_Prev_Sys_speed = uiCurrent_sys_speed;
  uint32_t uiSys_speed = 0;
  Types_FreqHz sCurr_CPU_freq;

  //check if the bios is running, this routine should not be used once it is
  if(bIs_BIOS_running == false)
  {
    //Get the current sys speed
    BIOS_getCpuFreq(&sCurr_CPU_freq);
    uiSys_speed = sCurr_CPU_freq.lo;
    //check if the current speed is not the same as the previous speed
    if(uiSys_speed != uiHW_delay_Prev_Sys_speed)
    {
      //The previous speed is not the same as the current speed
      //update delay control variables
      uiCurrent_sys_speed = uiSys_speed;
      //set the number of ticks for 1ms
      uiHW_delay_Sys_speed_1ms_ticks = uiCurrent_sys_speed / HW_DELAY_MSDIV;
    }else{/*do nothing*/}

    //check if the 1ms delay ticks control variable was not set
    if(uiHW_delay_Sys_speed_1ms_ticks == 0)
    {
      //Set the 1ms tick control variable
      uiHW_delay_Sys_speed_1ms_ticks = uiCurrent_sys_speed / HW_DELAY_MSDIV;
    }else{/*do nothing*/}

    for(i = 0; i < uiDelay; i++)
    {
      MAP_SysCtlDelay(uiHW_delay_Sys_speed_1ms_ticks);
    }
  }
  else
  {
    i = 0;
  }

  return i;
}

/******************************************************************************
* name: todo: fill out name, description, parameter and return
* description:
* param description: type - value: value description (in order from left to right)
*                    bool - true: do action when set to true
* return value description: type - value: value description
******************************************************************************/
ERROR_CODE eBSP_debugger_detect(void)
{
  ERROR_CODE eEC = ER_FAIL;
  uint32_t uiReg = 0;

  uiReg = HWREG(NVIC_DBG_CTRL);

  if((uiReg & NVIC_DBG_CTRL_C_DEBUGEN) == NVIC_DBG_CTRL_C_DEBUGEN)
  {
    eEC = ER_OK;
  }
  else
  {
    eEC = ER_FAIL;
  }

  return eEC;
}

//*****************************************************************************
// name: iBoard_init
// description: calls the low level board driver initalization functions
// param description: none
// return value description: 1 if success
//*****************************************************************************
ERROR_CODE eBSP_Board_init(void)
{
#ifdef USING_TIRTOS
  ERROR_CODE eEC = ER_OK;

  Board_initGeneral();
  Board_initADC();
  Board_initGPIO();
  Board_initWatchdog();
  Board_initUART();
  Board_initI2C();
  Board_initSPI();
  Board_initSDSPI();
  Board_initUSB(EK_TM4C123GXL_USBDEVICE);
  //Board_initADC();
  Board_initEEPROM();

  set_system_speed (INEEDMD_CPU_SPEED_FULL_EXTERNAL);

  return eEC;
#else
  return eEC;
#endif //#ifdef USING_TIRTOS
}
#endif //__BOARD_C__
